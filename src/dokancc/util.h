/*
  Dokan : user-mode file system library for Windows

  Copyright (C) 2018 Google, Inc.
  http://dokan-dev.github.io

This program is free software; you can redistribute it and/or modify it under
the terms of the GNU Lesser General Public License as published by the Free
Software Foundation; either version 3 of the License, or (at your option) any
later version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.

You should have received a copy of the GNU Lesser General Public License along
with this program. If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef DOKAN_UTIL_H_
#define DOKAN_UTIL_H_

#include <ntstatus.h>
#include <windows.h>

#include <condition_variable>
#include <functional>
#include <memory>
#include <string>
#include <vector>

#include "api.h"
#include "kernel_defs.h"

namespace dokan {

class Logger;

namespace util {

// Determines whether a file name without a path matches a search pattern that
// may contain wildcards. The matching is always case-insensitive. This behaves
// like the FsRtlIsNameInExpression function in the kernel. The pattern is
// uppercased by the constructor as that function requires.
class FileNameMatcher {
 public:
  FileNameMatcher() {}
  FileNameMatcher(const FileNameMatcher&) = delete;
  FileNameMatcher& operator=(const FileNameMatcher&) = delete;
  DOKANCC_API ~FileNameMatcher();

  DOKANCC_API bool Init(const std::wstring& pattern);
  DOKANCC_API bool Matches(const std::wstring& file_name);
 private:
  UNICODE_STRING pattern_ = {0};
};

// Rounds value up to the next value divisible by block_size.
DOKANCC_API int64_t Align(size_t block_size, int64_t value);

// Performs the following sanitizations, non-recursively, if needed:
// Replace initial "\\" with '\'
// Delete terminating '\'
DOKANCC_API std::wstring SanitizePath(const std::wstring& path);

// Removes the last path component from the given path and returns a path string
// that does not end with a separator unless it would otherwise be empty.
DOKANCC_API std::wstring StripLastPathComponent(const std::wstring& path);

// Strips the last path component of the given path and replaces it with the
// given name. Example: path = \foo\bar, name = xyz, return = \foo\xyz
DOKANCC_API std::wstring ReplaceLastPathComponent(const std::wstring& path,
                                                  const std::wstring& name);

// Splits the alternate stream name, if any, from the rest of a path.
// - If path is in the form dir\file:stream, then this function sets
//   path = dir\file and stream_key = stream
// - Otherwise, it sets stream_key = "" and leaves path intact.
DOKANCC_API void SplitAlternateStreamName(std::wstring* path,
                                          std::wstring* stream_key);

// Converts a device name generated by the driver, in the format \Volume{guid},
// into a prefixed path that works with CreateFile and similar functions.
DOKANCC_API std::wstring MakeDevicePath(const std::wstring& device_name);

// Creates a subpath string under a device name. The subpath may or may not
// begin with a blackslash.
DOKANCC_API std::wstring MakeDevicePath(const std::wstring& device_name,
                                        const std::wstring& subpath);

// Checks that the given driver version (presumably from the kernel) matches the
// version compiled into this library. If not, logs an error including both GUID
// strings to the given logger, and returns false.
DOKANCC_API bool CheckDriverVersion(const GUID& driver_version, Logger* logger);

// Sets a bool-like flag to true and signals a related condition variable.
template <typename T>
void SetAndNotify(std::mutex* mutex, std::condition_variable* cond, T* flag) {
  {
    std::unique_lock<std::mutex> lock(*mutex);
    *flag = true;
  }
  cond->notify_all();
}

inline void TimeToLargeInteger(const FILETIME& source, LARGE_INTEGER* dest) {
  dest->LowPart = source.dwLowDateTime;
  dest->HighPart = source.dwHighDateTime;
}

inline void LargeIntegerToTime(const LARGE_INTEGER& source, FILETIME* dest) {
  dest->dwLowDateTime = source.LowPart;
  dest->dwHighDateTime = source.HighPart;
}

// Converts a UTF-16 string to UTF-8, returning whether it was successful. This
// only fails if there are invalid multi-word sequences in the input string.
DOKANCC_API bool Narrow(const std::wstring& str, std::string* out);

using StatusCallback = std::function<void (NTSTATUS)>;

// Deletes a variable-sized struct that is backed by a char array.
template <typename T>
void DeleteVarStruct(T* x) {
  delete [] reinterpret_cast<char*>(x);
}

// A unique pointer to a variable-sized struct that is backed by a char array.
template <typename T>
using UniqueVarStructPtr = std::unique_ptr<T, decltype(&DeleteVarStruct<T>)>;

// Creates a zero-initialized variable length struct of type T backed by a
// buffer of the given size, and returns a unique pointer to it.
template <typename T>
UniqueVarStructPtr<T> MakeUniqueVarStruct(size_t size) {
  UniqueVarStructPtr<T> ptr(
      reinterpret_cast<T*>(new char[size]), &DeleteVarStruct<T>);
  memset(ptr.get(), 0, size);
  return ptr;
}

// Converts an existing raw pointer to a var-sized struct of type T into a
// unique pointer, with no modification of the object.
template <typename T>
UniqueVarStructPtr<T> MakeUniqueVarStruct(T* raw) {
  return UniqueVarStructPtr<T>(raw, &DeleteVarStruct<T>);
}

}  // namespace util
}  // namespace dokan

#endif // DOKAN_UTIL_H_
